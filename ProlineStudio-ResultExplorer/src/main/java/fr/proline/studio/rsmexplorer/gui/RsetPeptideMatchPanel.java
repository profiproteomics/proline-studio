/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package fr.proline.studio.rsmexplorer.gui;

import fr.proline.core.orm.msi.Peptide;
import fr.proline.core.orm.msi.PeptideMatch;
import fr.proline.studio.dam.tasks.SubTask;
import fr.proline.studio.pattern.AbstractDataBox;
import fr.proline.studio.pattern.DataBoxPanelInterface;
import fr.proline.studio.rsmexplorer.gui.model.PeptideMatchTableModel;
import fr.proline.studio.rsmexplorer.gui.renderer.PeptideRenderer;
import fr.proline.studio.utils.DecoratedTable;
import fr.proline.studio.utils.LazyTable;
import javax.swing.event.ListSelectionEvent;

/**
 *
 * @author JM235353
 */
public class RsetPeptideMatchPanel extends javax.swing.JPanel implements DataBoxPanelInterface {

    private AbstractDataBox dataBox;
    
    /**
     * Creates new form RsetPeptideMatchPanel
     */
    public RsetPeptideMatchPanel() {
        initComponents();

        ((DecoratedTable) peptideMatchTable).displayColumnAsPercentage(PeptideMatchTableModel.COLTYPE_PEPTIDE_SCORE);

        
    }

    @Override
    public void setDataBox(AbstractDataBox dataBox) {
        this.dataBox = dataBox;
    }
    public void setData(long taskId, PeptideMatch[] peptideMatches) {
        ((PeptideMatchTableModel) peptideMatchTable.getModel()).setData(peptideMatches);

        // select the first row
        if ((peptideMatches != null) && (peptideMatches.length > 0)) {
            peptideMatchTable.getSelectionModel().setSelectionInterval(0, 0);
        }
    }

    public void dataUpdated(SubTask subTask) {

        ((PeptideMatchTable) peptideMatchTable).dataUpdated(subTask);


    }
    
    
    public PeptideMatch getSelectedPeptideMatch() {

        PeptideMatchTable table = ((PeptideMatchTable) peptideMatchTable);

        // Retrieve Selected Row
        int selectedRow = table.getSelectedRow();

        // nothing selected
        if (selectedRow == -1) {
            return null;

        }

        // convert according to the sorting
        selectedRow = table.convertRowIndexToModel(selectedRow);



        // Retrieve ProteinSet selected
        PeptideMatchTableModel tableModel = (PeptideMatchTableModel) table.getModel();
        return tableModel.getPeptideMatch(selectedRow);
    }
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane = new javax.swing.JScrollPane();
        peptideMatchTable = new PeptideMatchTable();

        peptideMatchTable.setModel(new PeptideMatchTableModel((LazyTable)peptideMatchTable));
        scrollPane.setViewportView(peptideMatchTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable peptideMatchTable;
    private javax.swing.JScrollPane scrollPane;
    // End of variables declaration//GEN-END:variables


    private class PeptideMatchTable extends LazyTable  {
        /** 
         * Called whenever the value of the selection changes.
         * @param e the event that characterizes the change.
         */

        //ProteinSet proteinSetSelected = null;
        
        
        public PeptideMatchTable() {
            super(scrollPane.getVerticalScrollBar() );
            setDefaultRenderer(Peptide.class, new PeptideRenderer());
        }
        
        private int valueChangedCount = 0;
        
        /** 
         * Called whenever the value of the selection changes.
         * @param e the event that characterizes the change.
         */
        @Override
        public void valueChanged(ListSelectionEvent e) {
            
            super.valueChanged(e);
            
            if (selectionWillBeRestored) {
                return;
            }

            valueChangedCount++;
            
            System.out.println("valueChanged "+valueChangedCount); //JPM.REMOVE
            
            if (valueChangedCount % 100 == 0 ) {
                System.out.println("valueChanged "+valueChangedCount); //JPM.REMOVE
            }
            
            dataBox.propagateDataChanged(PeptideMatch.class);

        }
        
        /*public void selectProteinSet(Integer proteinSetId, String searchText) {
            ProteinGroupTableModel tableModel = (ProteinGroupTableModel) getModel();
            int row = tableModel.findRow(proteinSetId);
            if (row == -1) {
                return;
            }
            
            // JPM.hack we need to keep the search text
            // to be able to give it if needed to the panel
            // which display proteins of a protein group
            searchTextBeingDone = searchText;
            
            // must convert row index if there is a sorting
            row = convertRowIndexToView(row);
            
            // select the row
            getSelectionModel().setSelectionInterval(row, row);
            
            // scroll to the row
            scrollRowToVisible(row);

            searchTextBeingDone = null;
            
        }
        String searchTextBeingDone = null;*/

        public void dataUpdated(SubTask subTask) {
            
            LastAction keepLastAction = lastAction;
            try {
            
            
            // retrieve selected row
            int rowSelected = getSelectionModel().getMinSelectionIndex();
            int rowSelectedInModel = (rowSelected == -1) ? -1 : convertRowIndexToModel(rowSelected);

            // Update Model (but protein group table must not react to the model update)
            
            selectionWillBeRestored(true);
            try {
                ((PeptideMatchTableModel) getModel()).dataUpdated();
            } finally {
                selectionWillBeRestored(false);
            }

            
            
            // restore selected row
            if (rowSelectedInModel != -1) {
                int rowSelectedInView = convertRowIndexToView(rowSelectedInModel);
                setSelection(rowSelectedInView);
                
                // if the subtask correspond to the loading of the data of the sorted column,
                // we keep the row selected visible
                if (((keepLastAction == LastAction.ACTION_SELECTING ) || (keepLastAction == LastAction.ACTION_SORTING)) && (subTask.getSubTaskId() == ((PeptideMatchTableModel) getModel()).getSubTaskId( getSortedColumnIndex() )) ) {
                    ((PeptideMatchTable) peptideMatchTable).scrollRowToVisible(rowSelectedInView);
                }
                    
            }

            } finally {

                lastAction = keepLastAction;
 
            }
        }
        
        @Override
        public void sortingChanged(int col) {
            //((SearchButton)searchButton).sortingChanged();
        }
    
        public void selectionWillBeRestored(boolean b) {
            selectionWillBeRestored = b;
        }
        private boolean selectionWillBeRestored = false;
        
        
    }

}
